* 객체지향안어 = 프로그래밍 언어 + 객체지향개념(규칙)
* oop의 핵심 개념 - 캡슐화, 상속, 추상화, 다형성

1. 클래스와 객체
클래스란? 객체를 정의해놓은 것 (=제품의 설계도) > 객체를 생성하는 데 사용
객체란? 실제로 존재하는 것 (=제품) > 객체의 속성과 기능에 따른 용도의 차이
    * 객체를 사용한다 ? 객체가 가진 기능과 속성을 사용한다 (객체를 만드는 일이 쉬워지기 때문에 설계도를 작성!)
객체가 가진 속성(맴버변수)과 기능(매서드)을 객체의 맴버라고 한다
객체의 인스턴스화(제품생성)? 클래스 => 인스턴스(객체)
    * 인스턴스란 ? 특정 클래스로부터 생성된 객체 (객체와 인스턴스는 거의 같은 의미지만 객체 > 인스턴스)

* 소스파일의 이름은 public class 의 이름과 일치해야 한다 ! (소스파일 내에 public class 가 없다면? 소스파일 이름 아무거나 가능)
* 하나의 소스파일에서는 하나의 클래스만 작성하는 것이 바람직하다
* 하나의 소스파일에 둘 이상의 public class가 존재하면 안된다

2. 객체의 사용, 생성 (객체란 iv의 묶음이다)
* 객체를 사용한다? 객체가 가진 속성과 매서드를 사용한다
Tv t; // Tv 클래스 타입의 참조변수 t를 선언
t = new Tv(); // Tv인스턴스를 생성한 후 생성된 Tv인스턴스의 주소를 t에 저장 (참조변수 t를 통해 객체 접근가능)
* 연산자 new에 의해 tv객체가 메모라의 빈 공간에 생성된다 (이때 맴버 변수는 기본값으로 초기화됨)
* 이때 참조변수 t는 tv객체를 가리키고 있다(=참조하고 있다)
Tv t = new Tv(); // 위의 두 식을 주로 이렇게 한 줄로 표현한다

Tv1_1 t1 = new Tv1_1(); // TV1 인스턴스
t1.color = "검정색"; // 색깔 초기화 (참조변수 t에 저장된 주소에 있는 객체의 맴버변수 color에 색 저장)
* 인스턴스의 맴버변수(속성)을 사용하려먼 ? 참조변수.맴버변수
t1.power(); // 메서드 호출
** 인스턴스는 오직 참조변수를 통해서만 다룰 수 있으며 이때 참조변수의 타입은 인스턴스의 타입과 일치해야 한다 ! (tv클래스 타입의 참조변수 t)

t2 = t1; // TV2 인스턴스 참조변수에 TV1 인스턴스의 주소 저장 (참조변수 t1의 값을 t2에 저장)
* 참조변수 t2 에 저장되어있던 TV2 인스턴스 의 주소가 없어지고
// TV1 의 주소가 t2 참조변수에 저장이 됩니다
// 따라서 t2 = t1; 이후 부터는
// t2 참조변수로는 더 이상 TV2 인스턴스 에 접근할 수 없습니다. (그림으로 이해하면 쉽다)

2. 객체의 배열
객체 배열 == 참조변수 배열 (여러 개의 객체를 담을 수 있는 배열)
Tv[] tvArr = new Tv[3]; //길이가 3인 tv타입의 참조변수(객체) 배열 생성
* 객체 배열을 생성한 것은 참조변수들이 만들어진 것이다 > 객체를 객체배열의 각 요소에 저장 필요
tvArr[i] = new Tv; // 객체를 생성하여 배열의 각 요소에 저장
* 배열의 초기화 블럭 > Tv[] tv arr = {new Tv(), new Tv(), new Tv(),};
* 다뤄야 할 객체의 수가 많을 떄는 for문의 이용 Tv[] tvArr = new Tv[100];
for (int i = 0; i <tvArr.length; i++) {
    tvArr[i] = new Tv;
    }

String brand; // 브랜드 이름 속성 추가
for (int i = 0; i < tvArr.length; i++) {
    System.out.print(i + 1 + "번째 Tv인스턴스의 브랜드 명: " );
    System.out.println(tvArr[i].brand);
    }
    System.out.println();

// 새로운 참조변수에 배열 안에 들어있는 객체 주소 값 배정
Tv1_2 samsung = tvArr[0];
Tv1_2 lg = tvArr[1];
Tv1_2 apple = tvArr[2];

// 참조변수를 사용해서 배열안에 넣어준 객체에 접근해서 각 인스턴스에 브랜드 이름 추가하기
samsung.brand = "samsung";
lg.brand = "lg";
apple.brand = "apple";

for (int i = 0; i < tvArr.length; i++) {
System.out.print(i + 1 + "번째 Tv인스턴스의 브랜드 명: " );
System.out.println(tvArr[i].brand);
}

3. 클래스의 정의
클래스란? 1.설계도,  2.(서로관련된 다른타입의)데이터/변수 + 함수, 3.사용자정의타입(원하는 타입을 직접 만들 수 있다)

4. 변수의 종류 (선언위치에 따른)
클래스영역(맴버변수) : cv 클래스변수/공유변수(+ static), iv 인스턴스변수
메서드영역(+초기화블럭내부, 생성자) : lv 지역변수
* 클래스변수 ? 인스턴스 변수 앞에 static, 객체생성을 하지 않아도 된다, 언제든지 사용 가능, 클래스가 메모리에 올라갈 때 생성
접근방법 : 클래스명.클래스변수이름
* 인스턴스 변수 ? 객체 생성시 생성, 접근방법 : 참조변수명.인스턴스변수명
* 지역변수 ? 매서드 호출되서 실행시 생성, 메서드 종료시 자동제거
void method() {
int lv;
lv = 30; }
// 지역변수는 자동으로 초기화가 되지 않기 때문에 사용하려면 반드시 초기화 필요

// 인스턴스 변수 생성 및 사용
// Obj4_1.iv = 20; // Error, 인스턴스를 통해서만 생성 및 사용 가능
Obj4_1 objVar = new Obj4_1();
objVar.iv = 20;
System.out.println("objVar.iv 인스턴스 변수 = " + objVar.iv);

// 지역 변수 생성 및 사용
// objVar.lv // Error, 인스턴스로 지역 변수 바로 접근 불가능
objVar.method(); // 메서드 호출 시 지역 변수 생성
// 메서드 종료시 지역 변수 삭제
** (객체란 iv의 묶음이다)
** 클래스변수는 모든 인스턴스가 하나의 저장공간을 공유하므로 항상 공통된 값을 갖는다

5. 매서드
매서드란 작업단위로 문장들을 묶은것으로 값(입력)을 받아서 처리 후 결과들을 반환(출력)한다 (입출력값이 없을 수도 있음)
반드시 class 안에 들어있어야 하며 객체지향개념에서의 함수이다
*반복적으로 수행되는 여러 문장을 메서드로 작성합니다.
하나의 메서드는 한 가지 기능만 수행하도록 작성하는 것이 좋습니다
매서드는 동사형으로 작성한다 ex.add,print--
int add(int x, int y) //선언부 {
=> int(반환타입) add(메서드 이름) int x, int y(매개변수(입력))
int result = x + y; => 처리
return result;  => 결과를 반환 //메서드호출시 수행할 코드(구현부)
}
void(반환타입) : 메서드 수행 시 아무것도 반환하지 않을 때 사용합니다

메서드 호출 (메서드를 호출해야 구현부의 문장들이 실행된다)
메서드이름(값1, 값2, ... ); //(작업에 필요한 값들: 0~n개) //main 메서드는 자동으로 호출된다!!
Method5_1 method = new Method5_1(); // Method5_1 클래스에 만든 메서드 add 를 사용하기 위해 객체 생성
😃참조변수를 통해 class 내의 객체에 접근한다 p167,180참고😃
int result = method.add(3, 5); // add 메서드를 사용해서 입력한 값(3,5)으로 처리된 값을 반환받아 result 변수에 저장

print99danAll(); //void print99danAll() 호출
int result = add(3,5); //int add(int x, int y)를 호출하고 결과를 result에 저장

return : 실행중인 메서드를 종료 후 호출한 곳으로 되돌아간다
반환타입이 void가 아닌 경우, 반드시 return 문이 필요합니다.
void 는 컴파일러가 자동으로 메서드 마지막에 return; 을 추가해 줌

예시     class Method5_2 {
void gugudan(int dan) {
if (!(dan >= 2 && dan <= 9)) {
System.out.println(dan + "단은 없습니다.");
return;
}
System.out.println(dan + "단 시작!");
for (int i = 1; i < 10; i++) {
System.out.println(dan + "*" + i + " = " + dan * i);
}
System.out.println();
}

boolean checkMax(int x, int y) {
if (x > y) {
return true;
} else {
return false;
// return 반드시 필요합니다. 만약 없으면 조건문이 false 일 경우, void 가 아닌데 return 문이 없음으로 Error
}
}

}

class Method5_2Main {
public static void main(String[] args) {
Method5_2 method = new Method5_2();

method.gugudan(2);
method.gugudan(5);
method.gugudan(10);
method.gugudan(9);

System.out.println("method.checkMax(10, 8) = " + method.checkMax(10, 8));
System.out.println("method.checkMax(5, 9) = " + method.checkMax(5, 9));
}
}

문장들의 묶음 : 코드의 중복을 하나의 묶음으로 만들어 가독성과 효율을 높여준다 !
class Time5_1 {
int hour;
int minute;
int second;
}

class Method5_3 {
static void initObj(Time5_1 time, int hour, int minute, int second) {
time.hour = hour;
time.minute = minute;
time.second = second;
}
}

class Method5_3Main {
public static void main(String[] args) {
Time5_1 t1 = new Time5_1();
t1.hour = 100;
t1.minute = 20;
t1.second = 43;

Time5_1 t2 = new Time5_1();
t2.hour = 22;
t2.minute = 30;
t2.second = 23;

Time5_1 t3 = new Time5_1();
t3.hour = 45;
t3.minute = 40;
t3.second = 52;

System.out.println("t1.hour = " + t1.hour);
System.out.println("t2.hour = " + t2.hour);
System.out.println("t3.hour = " + t3.hour);
System.out.println();

// 하나하나 인스턴스를 만들고 위처럼 인스턴스 변수를 초기화 하려니 매우 귀찮지 않나요?
// 물론 '생성자' 라는 개념이 뒤에 나오지만 일단은 메서드를 사용하여 코드의 수를 확 줄여 보겠습니다.

Time5_1 t4 = new Time5_1();
Time5_1 t5 = new Time5_1();
Time5_1 t6 = new Time5_1();

Method5_3.initObj(t4, 100, 20, 43);
Method5_3.initObj(t5, 22, 30, 23);
Method5_3.initObj(t6, 45, 40, 52);

System.out.println("t4.hour = " + t4.hour);
System.out.println("t5.hour = " + t5.hour);
System.out.println("t6.hour = " + t6.hour);

// 이처럼 메서드를 사용하니 코드의 수가 굉장히 많이 줄어 가독성이 좋아졌습니다.
}
}

호출스택 : 매서드 수행에 필요한 메모리가 제공되는 공간, 메서드 호출 시 호출스택에 메모리 할당, 종료 시 해제

6. 기본형 매개변수와 참조형 매개변수 (매개변수/파라미터 = 지역변수/lv)
기본형 : read only (기본형의 값이복사된다)
참조형 : read & write (참조형의 인스턴스(객체)주소가 복사된다) 😃그림으로 그려서 이해 😃

참조형 반환타입

7. static 매서드와 인스턴스 매서드
static 메서드(클래스 메서드)
객체 생성 없이 '클래스이름.메서드이름()'으로 호출 : ex) Math.random()
인스턴스 멤버(인스턴스 변수, 인스턴스 메서드) 와 관련없는 작업을 하는 메서드
메서드 내에서 인스턴스 변수 사용 불가합니다.

인스턴스 메서드
인스턴스를 생성한 후, '참조변수.메서드이름()' 으로 호출
인스턴스 멤버(인스턴스 변수, 인스턴스 메서드)와 관련된 작업을 하는 메서드
메서드 내에서 인스턴스 변수 사용가능합니다

8. (매서드) 오버로딩
한 클래스 안에 같은 이름의 메서드를 여러 개 정의하는 것입니다.
오버로딩의 성립 조건
메서드 이름이 같아야 합니다.
매개변수의 개수 또는 타입, 위치가 달라야 합니다.
반환(리턴)타입에는 영향을 받지 않습니다.
사용을 하는 목적
매개변수 즉, 입력하는 값이 다르지만 같은 기능을 수행하는 경우가 많을 때 사용성 및 효율을 높이기 위해 오버로딩을 사용합니다.
ex) print() {} , add() {}

9. 생성자
클래스이름(타입변수명, 타입변수명...) {
//인스턴스 생성시 수행될 코드, 주로 인스턴스 변수의 초기화 코드를 적는다
}
인스턴스가 생성될 때마다 호출되는 '인스턴스 초기화 메서드' 입니다.
인스턴스 생성시 수행할 작업에 사용됩니다. (연산자 new가 인스턴스를 생산하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다)
초기값이 필요한 인스턴스 변수의 값을 초기화 해줍니다.
생성 조건
이름이 클래스 이름과 같아야 합니다.
return 값이 없습니다. (void는 붙이지 않습니다.)
오버로딩 가능합니다. (* 모든 클래스는 반드시 생성자를 1개 이상 가져야 한다)

기본 생성자
매개변수가 없는 생성자를 의미합니다.
생성자를 하나도 선언되어 있지 않았을 때는 컴파일러가 자동으로 추가해 줍니다.
class Tv9_1 {
// 속성 : 변수 선언
boolean power; // 전원상태
int channel;  // 채널
String color; // 색깔
long price; // 가격

// 위 속성에서 필수로 초기값이 필요한 값들을 초기화 해주는 기본 생성자
public Tv9_1() {
power = false;
channel = 1;
}

//  오버로딩 한 생성자 - 매장 진열 용 일 경우에는 가격과 색깔의 초기화가 필요합니다. this 는 이전 챕터에서 잠깐 봤었죠! 매개변수와 인스턴스변수를 구분하기 위해 사용하겠습니다.
public Tv9_1(String color, long price) {
power = false; // this.power, power 둘다 지금 상황에서는 인스턴스 변수를 명확하게 판단 할 수 있기 때문에 어떤걸 사용해도 상관 없습니다.
channel = 1;
this.color = color;
this.price = price;
}

// 기능 : 메서드 선언
void power() {  // 전원 기능
power = !power;
if (power) {
System.out.println("전원 ON");
} else {
System.out.println("전원 OFF");
}
}

void channelUp() { // 채널 증가
channel++;
System.out.println("채널 증가");
}

void channelDown() { // 채널 감소
channel--;
System.out.println("채널 감소");
}

}

class Tv9_1Main {
public static void main(String[] args) {
// 기본 초기화된 Tv9_1 생성
Tv9_1 tv = new Tv9_1();
System.out.print("기본 생성자 TV: ");
tv.power();

// 진열 용 Tv9_1 생성
Tv9_1 exTv = new Tv9_1("보라색", 3456789);
System.out.print("오버로딩 생성자 TV: ");
exTv.power();
System.out.println("exTv.color = " + exTv.color);
System.out.println("exTv.price = " + exTv.price);

// 근데 이때 주의할 점!
// 기본 생성자는 없고 오버로딩한 생성자만 있을 경우!
// 컴파일러는 기본 생성자를 만들어주지 않기 때문에 기본 생성자를 사용하려고 하면 Error 발생!
// 위 기본 생성자를 주석 하세요!!!!
Tv9_1 tv2 = new Tv9_1(); // Error 발생, 기본 생성자가 없기 때문에 매개 변수를 넣으라고 intellij 가 요구합니다.

}
} 😃200,206p같이ck

10. this 와 this()
this
인스턴스 자신을 가리키는 참조변수 입니다.
인스턴스 메서드(생성자 포함) 에서 사용 가능합니다.
지역 변수 와 인스턴스 변수를 구별할 때 사용합니다
* 인스턴스의 주소가 저장되어 있다, 모든 인스턴스매서드(생성자를 포함)에 지역변수로 숨겨진 채로 존재 (선언을 안해도 사용가능하다)
this()
생성자 에서 다른 생성자를 호출할 때 사용합니다. (코드의 중복을 제가하기 위해 사용)
this() 를 사용하지 않고 클래스명(); 이렇게 생성자를 호출하려고 하면 Error 가 발생합니다.
다른 생성자 호출시 첫 줄에서 만 사용 가능합니다

11. 변수의 초기화
수동 / 자동 초기화
지역 변수는 수동으로 초기화 해야합니다.
지역 변수가 동작하는 스택 메모리는 재사용이 빈번하기 때문에 매번 초기화 해주면 성능이 떨어집니다.
그래서 그냥 해당 메모리에 있는 값으로 덮어 씌웁니다.
근데 해당 주소에 어떠한 값이 있는지 모르기 때문에 Java는 개발자에게 수동으로 초기화 하라고 요구합니다.
C 언어에서는 이를 garbage value 라 부릅니다.(C언어와 Java의 차이를 비교하면 이해가 쉽습니다.)
멤버변수(인스턴스 변수, 클래스 변수)는 자동으로 초기화 됩니다.

멤버 변수의 초기화
클래스 변수 : 클래스가 처음 로딩될 때 단 한번만 초기화 됩니다.
인스턴스 변수 : 인스턴스가 생성될 때 마다 초기화 됩니다

초가화방법 : 자동 , 간단 = , 복잡  {} > static {} (cv) > 생성자 (iv)
순서 : cv > iv
* 맴버변수(cv,iv)와 배열의 초기화는 선택이지만 지역변수의 초기화는 필수이다 !
class Tv11_3 {
// 속성 : 변수 선언
boolean power; // 전원상태
int channel;  // 채널
String color; // 색깔
long price; // 가격

// 위 속성에서 필수로 초기값이 필요한 값들을 초기화 해주는 기본 생성자
Tv11_3() {
this.power = false;
this.channel = 1;
}
...
}



